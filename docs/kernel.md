
# Микро-ОС Neos (Neocore OS)  

ОС предназначена для управления асинхронными задачами в модулях беспроводной связи сенсорной сети и обеспечения эффективного энергопотребления.          
Ядро ОС использует абстрактный аппаратный уровень HAL микроконтролера.    
HAL инициализируется отдельно, до запуска планировщика. Есть ряд функций,    
используемые ядром и имеющие заглушки (светодиоды, uart)                     
Управление системным таймером, режимом ожидания занимается ядро.                                                                             
Модули могут напрямую использовать аппаратуру МК, к примеру обработчики      
прерываний через hal


# Устройство операционной сисетемы NEOS

## Функционал ядра

* Hardware abstraction layer
  Поддержка различной аппаратуры микроконтролера.

* Event manager
  Регистрирует события возникшие в системе

* Task manager
  Размещает задачи в очереди, сортирует очередь по приоритетам, извлекает 
  задачи из очереди.

* Task scheulder
  Планировщик задач. Просматривает возникшие события в системе и устанавливает 
  задачи в очередь планировщика. 
  Выполняет задачи из очереди, при отсутвии задач переводит
  ядро в режим пониженного энергопотребления. 

* Core debug printf
  Вывод отладочной информации в uart c категориями отладки.

* Kernel panic
  Обработка исключитильные ситуации в ядре (переполнение очереди событий, задач, 
  возникновение необрабатываемых прерываний, сторожевой таймер).

* WDT
  Планировщик задач сбрасывает WDT. При возникновении прерывания WDT при 
  зависании пользовательской программы управление передается kernal_panic.

* Init service
  Передает управление зарегистрированным службам в строго определенном порядке.
  Используется для контроля запуска приложений после загрузки системы.
  Если не проконтролировать порядок запуска, то приложение управляющее 
  светодиодами может инициализироваться раньше чем таймеры. Это может 
  привести к краху системы. Функциональная нагрузка модуля аналогична 
  linux initd.  

## Системные приложения

* Таймеры
  Программируемый таймер, который может периодически или однократно выставлять
  задачи ранее зарегистрированные. Такой таймер тактируется от системной шины
  и отключается когда контроллер уходит в глубокий сон.
  Программируемый таймер реального времени работает всегда. По истечению
  заданного интервала времении выставляет задачу в очередь. Может быть
  периодическим или однократным.

* Светодиодная индикация
  Приложение получает команду на отображение того или иного состояния системы.
  Содержит буфер команд. Может отображать числа.

* Задержки
  Приложение используя таймер реализует задержки мс, мкс. 
  Приложение может блокировать прерывания для спец. таймеров.

* Доска обьявлений
  Предоставляет возможность приложению оповещать другие приложения о своем 
  состоянии без непосредственного вызова. Все заинтересованные приложения
  могут проверить состояние системы. Примером служит состояние подключения 
  к беспроводной сети.

* База данных
  Хранение информации в формате:  
  (код физ. величины)+(номер)/значение.    
  код физической величины - Амперы, Вольты, Градусы, Скорость, Состояние
  номер - от 0 до 7. Номер датчика который произвел измерения
  Булево знач. (true/false)

  КФВ -        4 бит
  Номер -      3 бит
  Булево знач. 1 бит

  Значение - 4 байта

  КФВ = 0 Для данных с бинарным состоянием. При этом значения сохраняется
  в поле Булево значение

* Измерение напряжения

Операционная система состоит из менеджера событий, диспетчера задач, аппаратного уровня абстракций (HAL). 

## Порядок загрузки ядра
0. Блокировка глобальных прерываний
1. Перевод тактового генератора MCU на HSI 16 Мгц
2. Запуск часового кварца
3. Установка системного таймера на интервал 1мс
4. Запуск таймера пробуждения MCU из глубокого сна
5. Инициализация подсистемы HAL
6. Инициализация модуля событий
7. Постановка первого события 'booted'
8. Разрешение прерываний
9. Запуск цикла диспечера задач

## Модуль событий
Модуль представляет собой простую очередь FIFO с блокировкой повторного размещения элемента. Настройки модуля в файле kernel_configuration.h.
Модуль производит постановку события в очередь, извлечение событий из очереди.
При попытке поставить в очередь событие уже установленное, функция успешно завершит свою работу. При превышении максимальной глубины очереди, ядро перейдет в режим kernel panic.
Функции модуля:

### kcodes core_push_event(k_event event)
Возвращает k_ok. 

### kcodes core_pop_event(k_event *event)
Возвращает k_ok и помещает событие в *event.
Если в очереди нет событий возвращает k_noevents.

### kcodes core_event_manager_init(void)
Подготавливает переменные модуля.
Возвращает k_ok.    

## Модуль задач
Заносит задачи в список выполнения, сортирует по приоритету.


## Модуль диспечера задач
Модуль обрабатывает возникшие в системе события и размещает их в очереди задач согласно их приоритету. При отсутвии союытий и задач для выполнения, модуль вызывает функцию ядра kcodes core_idle() 

### kcodes core_scheulder_loop(void)
Иницилизирует и запускает менеджер задач.
Выход из функции не предусмотрен.

Алгоритм работы диспетчера задач:
1. Иницилизация
2. Извлечение события
3. Поиск обработчика события
4. Добавление обработчиков в список
5. Если события не кончились то переходим к п.2
6. Если очередь пуста то вызываем core_idle() -> переход к п.2.
6. Сортировка списка по приоритету
7. Выполнение первого задания из списка (и его удаление из списка).
8. Переход п.2

## Модуль обработчиков событий
Модуль обработчиков событий возвращает указатель на список обработчиков и
их количество. Список обработчкиков содержит приоритет задачи. Списки компилируется статически. 
Для добавления новых событий или обработчиков требуется отредактировать
файл core_even_handler. В нем содержатся статические указатели.


### kcodes core_event_handlers(k_event event, core_task *tasks, uint16_t task_num)
Возвращает k_ok и указатель на список обработчиков и их количество.
Если подписчиков нет, то task_num = 0.
Если запрашиваемое событие не существует (>=EVENT_LASTEVENT_IN_ENUM)
то вызывается Kernel_panic

## Kernel panic

## kcodes core_idle()

## Атомарность операций

##  Ядро NEOS

## Модульное тестирование
Модуль производит автоматическое тестирование кода и сохранение результата тестирования.
В коде core_unit_tests.c определены внешнии функции, которые будут вызваны
для тестирования. Функции имеют прототип int TUNIT_xxxx(char *msg), и должны начинатся строго с имени TUNIT_. Если результат исполнения отличен от 0, то тестирование не прошло и сообщение ошибки помещается в *msg.
Работа модуля зависит от наличия флага UNIT_TEST в файле kernel_configuration.h.
Если он определен, то после иницилизации HAL будет выполнено тестирование.
Результат тестирования ни как не влияет на дальнейший ход исполнения программы.
Тестированию подвергаются не аппаратно-зависимые участки кода. Примером
такого кода может служить тестирования менеджера задач.

## Диагностика оборудования
Запуск диагностики различных подсистем в начале загрузки ядра.
Диагностика происходит после настройки HAL.


## Сиситемные приложения
src/app/sys
 - Программируемые таймеры
 - Светодиодная индикация (очередь команд)
 - Командная строка uart
 - Менеджер конфигураций, настроек
 - Статистический модуль
 - АЦП
 - 

## Сетевые приложения
src/app/net
 - Реализация протокола



### Установка отладчика gdb
Имя пакета было изменено на gdb-arm-none-eabi.
sudo apt install gdb-arm-none-eabi
установит приложение:
arm-none-eabi-gdb