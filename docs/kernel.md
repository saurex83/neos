
# Микро-ОС Neos (Neocore OS)  

ОС предназначена для управления асинхронными задачами в модулях беспроводной
связи сенсорной сети и обеспечения эффективного энергопотребления.          
Ядро ОС использует абстрактный аппаратный уровень HAL микроконтролера.       
HAL инициализируется отдельно, до запуска планировщика. Есть ряд функций,    
используемые ядром и имеющие заглушки (светодиоды, uart)                     
Управление системным таймером, режимом ожидания занимается ядро.                                                                             
Модули могут напрямую использовать аппаратуру МК, к примеру обработчики      
прерываний  

# Устройство операционной сисетемы NEOS

Операционная система состоит из менеджера событий, диспетчера задач, аппаратного уровня абстракций (HAL). 

## Порядок загрузки ядра
0. Блокировка глобальных прерываний
1. Перевод тактового генератора MCU на HSI 16 Мгц
2. Запуск часового кварца
3. Установка системного таймера на интервал 1мс
4. Запуск таймера пробуждения MCU из глубокого сна
5. Инициализация подсистемы HAL
6. Инициализация модуля событий
7. Постановка первого события 'booted'
8. Разрешение прерываний
9. Запуск цикла диспечера задач

## Подсистема HAL
Подсистема состоит из раздельных модулей с именем HAL_xxx.c (HAL_ADC.c)  и заголовочным файлом HAL_xxx.h (HAL_ADC.h). Каждый модуль выполняеть только свойственный ему функционал, не нужно создавать универсальные модули. Модуль 
может использовать другии модули и поэтому важен порядок инициализации.
Инициализация модулей происходит в файле hal.c, он же определяет ее порядок.

### hal_ret hal_init(void)

## Модуль событий
Модуль представляет собой простую очередь FIFO с блокировкой повторного размещения элемента. Настройки модуля в файле kernel_configuration.h.
Модуль производит постановку события в очередь, извлечение событий из очереди.
При попытке поставить в очередь событие уже установленное, функция успешно завершит свою работу. При превышении максимальной глубины очереди, ядро перейдет в режим kernel panic.
Функции модуля:

### kcodes core_push_event(k_event event)
Возвращает k_ok. 

### kcodes core_pop_event(k_event *event)
Возвращает k_ok и помещает событие в *event.
Если в очереди нет событий возвращает k_noevents.

### kcodes core_event_manager_init(void)
Подготавливает переменные модуля.
Возвращает k_ok.    

## Модуль задач
Заносит задачи в список выполнения, сортирует по приоритету.


## Модуль диспечера задач
Модуль обрабатывает возникшие в системе события и размещает их в очереди задач согласно их приоритету. При отсутвии союытий и задач для выполнения, модуль вызывает функцию ядра kcodes core_idle() 

### kcodes core_scheulder_loop(void)
Иницилизирует и запускает менеджер задач.
Выход из функции не предусмотрен.

Алгоритм работы диспетчера задач:
1. Иницилизация
2. Извлечение события
3. Поиск обработчика события
4. Добавление обработчиков в список
5. Если события не кончились то переходим к п.2
6. Если очередь пуста то вызываем core_idle() -> переход к п.2.
6. Сортировка списка по приоритету
7. Выполнение первого задания из списка (и его удаление из списка).
8. Переход п.2

## Модуль обработчиков событий
Модуль обработчиков событий возвращает указатель на список обработчиков и
их количество. Список обработчкиков содержит приоритет задачи. Списки компилируется статически. 
Для добавления новых событий или обработчиков требуется отредактировать
файл core_even_handler. В нем содержатся статические указатели.


### kcodes core_event_handlers(k_event event, core_task *tasks, uint16_t task_num)
Возвращает k_ok и указатель на список обработчиков и их количество.
Если подписчиков нет, то task_num = 0.
Если запрашиваемое событие не существует (>=EVENT_LASTEVENT_IN_ENUM)
то вызывается Kernel_panic

## Kernel panic

## kcodes core_idle()

## Атомарность операций

##  Ядро NEOS

## Модульное тестирование
Модуль производит автоматическое тестирование кода и сохранение результата тестирования.
В коде core_unit_tests.c определены внешнии функции, которые будут вызваны
для тестирования. Функции имеют прототип int TUNIT_xxxx(char *msg), и должны начинатся строго с имени TUNIT_. Если результат исполнения отличен от 0, то тестирование не прошло и сообщение ошибки помещается в *msg.
Работа модуля зависит от наличия флага UNIT_TEST в файле kernel_configuration.h.
Если он определен, то после иницилизации HAL будет выполнено тестирование.
Результат тестирования ни как не влияет на дальнейший ход исполнения программы.
Тестированию подвергаются не аппаратно-зависимые участки кода. Примером
такого кода может служить тестирования менеджера задач.

## Диагностика оборудования
Запуск диагностики различных подсистем в начале загрузки ядра.
Диагностика происходит после настройки HAL.


## Сиситемные приложения
src/app/sys
 - Программируемые таймеры
 - Светодиодная индикация (очередь команд)
 - Командная строка uart
 - Менеджер конфигураций, настроек
 - Статистический модуль
 - АЦП
 - 

## Сетевые приложения
src/app/net
 - Реализация протокола

## Работа с программатором на Linux
### Установка st-link
Для работы с программатором st-link требуется установить:
У меня была проблема с компиляцией, важно установить
cmake и libusb. Причем если установить пакет libusb-dev то приложение не будет 
собираться. нужно именно libusb-1.0-0-dev.
Для установки программы:
cd build/Release
make install

Еще одна особенность- запусти /sbin/ldconfig для обновления установленых
библиотек в системе. Без этого будет ругаться на libstlink.so.1

sudo apt-get install libusb-1.0-0-dev
git clone https://github.com/texane/stlink stlink.git
cd stlink
make
//install udev rules
sudo cp etc/udev/rules.d/49-stlinkv* /etc/udev/rules.d/
//and restart udev
sudo udevadm control --reload

### Установка отладчика gdb
Имя пакета было изменено на gdb-arm-none-eabi.
sudo apt install gdb-arm-none-eabi
установит приложение:
arm-none-eabi-gdb

### Прошивка 
st-flash  write firmware.bin  0x08000000

## Работа с отладчиком
Сначало запускается gdb-server:
st-util -2 -p 4500

Потом отладчик:
arm-none-eabi-gdb template.elf

Подключаемся к серверу:
tar ext :4500

Загружаем прошивку:
load

Запускаем:
continue (или run)

Установка точки остановки:
b main

Остановка программы:
CNTR-C

Есть еще возможноть запускать с ключом -tui

