# Реализация стека беспроводного протокола

## Модули стека протоколов

Определяет структуры данных сетевого протокола

Тип данных uint8_t ntwPacketType_t:
  * ptBroadCast
  * ptUnicCast
  * ptACK
  * ptRTS
  * ptCTS

Тип данных uint32_t ntwAddress_t
Представление сетевых адрессов


Тип данных uint16_t ntwPANAddress_t
Представление сетевых адрессов

Тип данных void (packetFunctionF)(ntwPacket_t packet)
Указатель на фунцию-обработчик пакета

Тип данных uint32_t recvTimeStamp_t 
Временая метка приема сигнала. Пока незнаю в каких величинах ее считать
и отнсительного какого таймера брать значение. Есть мысль использовать 
системный таймер. При появлении SFD брать значение системного таймера 
в мкс.Системный таймер 24 бита. Его хватит на 16.7 сек.

Тип данных signed char rssi_t
Качество принимаемого сигнала в дбм

Структура ntwPacket_t:
  * union
  	** uint8_t rawdata[127] - сырые данные протокола
  	** uint8_t payload[xxx]	- полезная нагрузка		
  * ntwPacketType_t packetType 	- тип пакета
  * uint8_t payloadSize - размер полезной нагрузки
  * ntwAddress_t SRC - получатель пакета
  * ntwAddress_t DST - отправитель пакета
  * ntwPANAddress_t PAN - идентификатор сети
  * recvTimeStamp_t - время приема пакета
  * rssi_t - сила сигнала
  * packetFunctionF pack(ntwPacket_t packet) - упаковка в структуру протокола
  * packetFunctionF unpack(ntwPacket_t packet) - распаковка

### Радио модуль. radioInterface
Реализует интерфейс управления радиопередатчиком
При приеме сигнала заолняет поля ntwPacket_t recvTimeStamp_t и rssi_t
Использует:
  * HAL

Предоставляет:
  * radioConfig_t - парметры настройки
  * radio_on()
  * radio_off()
  * radio_config(...)
  * radio_sendBuf(ntwPacket_t packet)
  * radio_recvBuf(ntwPacket_t packet)
  * radio_AESCode(ntwPacket_t packet)
  * radio_AESDecode(ntwPacket_t packet)
  * radio_loadAESCode(...)

### Интерфейс wkUpTimer
Интерфейс предоставляет функции управления таймером сна. При помощи данного
интерфейса планировщик временных слотов обеспечивает синхронизацию временных
слотов и узла с интервалами сети.

Использует:
  * HAL

Предоставляет:
  * wkuTimerSet(us_t us)
  * wkuTimerRegInterrupt(void)

### Модуль networkTimePlane
Модуль отвечает за планирование временных слотов сети и выполнение функций 
приема-передачи исходя из текущего временного слота. Модуль работает внутри 
прерывания и блокирует все внешнии прерывания на время своей работы.  
Работа модуля основывается на таблице timeSlotsTable содержащая структуры 
timeSlot_t. Таблица имеет размер равный количеству временных слотов в 
беспроводном протоколе neocore. В эту таблицу можно добавлять или удалять
временные слоты. Действие необходимое для осуществление описывается элементом
таблици timeSlot_t. При вычислении времен следующей активности стека
протокола используется таблица timeSlotsTable. Алгоритм выбирает следующий
слот в котором есть действие (timeSlotAction_t), вычисляет время оставшееся 
до наступления временого слота и записывает в wkuTimerSet. Для действий
saDeactivated и saActionComplet планировка не осуществляется. 
После обработки временного слота, состояние поля timeSlotAction_t 
этого timeSlot_t изменят сове состояние на saActionComplet.
При передаче данных используется поле rawdata структуры ntwPacket_t.
Предполагается что пользователь в таймслот загрузил шотовый пакет.
При пиреме данных используется два разных алгоритма: ШВС и unicast.
ШВС алгоритм принимает пакеты принадлежащии сети в которой зарегестрирован узел.
Unicast принимает пакеты по схеме RTS/CTS/ACK. Приняв пакет RTS адресованый
нашему узлу и из нашей сети, узел ответает CLS и принимает пакет данных.
Прием пакета данных подтверждается отправкой сообщения ACK.
Качество сигнала по завершению приема записывается в поле radioInfo_t.
Предача пакета ШВС осуществляется без подтверждения. За каждый таймслот 
предпринимается только одна попытка отправки ШВС сообщения.
Передача unicast происходит по схеме RTS/CTS/ACK. 
При передаче производится контроль CCA. Если канал занят попыток в этот
таймслот более не предпринимается.
Модуль networkTimePlane после завершения обработки слота выставляет
системное событие evTimeSloteFinish.
Модуль производит синхронизацию с сетью по средством wkuTimerSet().
После передачи управления модулю, он вычисляет через сколько времени начнется
следующий тайм слот и значение + usOffset передает в  wkuTimerSet().
После коректировки usOffset приравнивается к 0.  
Функция wkuTimerSet() слабое место в синхронизации, так как для перенастройки
регистра wutr (интервала просыпания) требуется некоторое время в течении 
которого таймер не работает, как минимум 2 такта RTCCLK (2x30мкс). Будет
не плохо если ошибка синхронизации будет до 100 мкс в этом случаи за 1 сек.
Так как за 1 сек (суперфрейм) будет 20 таймслотов(50 мс) то ошибка 
накапливается.
Второй вариант синхронизации это подключить syncpre к wut и использовать
возможность МК после asyncpre коректировать ppm. С ним не очень ясно как 
реализовать на практике.
Почитав по tinyOS узнал что они используют 32768 таймер который пробуждает
микроконтролер на каждом счете(я так думаю) и устанавливает event.
Еще вариант: время сети измерять в долях 32.768 lse. К примеру 
network quant равен 32/32768 (около 1 мс). Wakeup timer выводит МК из сна и 
ставит событие evNetworkQuantRise и выходит из прерывания. Планировщик ОС
повышает частоту МК до 16 мгц и начинает обрабатывать события.
Обработчик evNetworkQuantRise инкрементирует 64 битный счетчик и проверяет 
нужно ли генерировать новые события, которые достигли своего часа.
evNetworkQuantRise может генерировать события периодически или однократно.


Тип данный uint8_t tsNum_t

Тип данных timeSlotAction_t:
 Обозначает действие, которое необходимо осуществить в временном слоте
 * saRecvBroadCast - получение ШВС
 * saSendBroadCast - передача ШВС
 * saRecvLocalMsg  - получение локального входящего пакета
 * saSendLoaclMsg  - передача локального исходящего пакета
 * saDeactivated   - слот не используется
 * saActionComplet - действие совершено

Структура данных radioInfo_t:
  * uint8_t channel
  * schar   rssi

timeSlot_t состоит из :
  * radioInfo_t - настройка радио
  * timeSlotAction_t 
  * ntwPacket_t - сетевой пакет
  * tsNum_t - номер таймслота в массиве timeSlotsTable

Использует:
  * wkUpTimer
  * HAL_Interrupts
  * radioInterface
  * neos. kernel_panic()
  * neos. events.h

Предоставляет:
  * int tpGetFreeTimeSlot(timeSlot_t timeSlot) 
    Возвращает указатель на свободный временной слот.
    0 в случаи успеха, иначе -1
  * void tpFreeTimeSlot(timeSlot_t timeSlot)
    Деактивирует таймслот
  * void tpSetTimeSlot(timeSlot_t timeSlot)
    Записывает таймслот в таблицу timeSlotsTable
  * void tpSetAction(timeSlot_t timeSlot, timeSlotAction_t action)
    Устанавливает состояние таймслота по указателю timeSlot
  * timeSlotAction_t tpGetAction(timeSlot_t timeSlot)
    Возвращает состояние таймслота по указателю
  * void tpSyncOffset(float usOffset) 
    сообщает о смещение интервалов приема суперфрейма. Модуль коректирует
    следующий таймслот на usOffset

## Модуль networkDataProcess
Модуль обслуживает событие evTimeSloteFinish и производит обработку
принятых пакетов, устанавливает на передачу пакеты данных, производит 
маршрутизацию пакетов, управляет синхронизацией сети (отдает ошибку временного
рассогласования модулю networkTimePlane).

## Модуль networkSearch
Модуль производит поиск активной сети

## networkStateControl
Осуществляет надзор над работой беспроводной сети, иницилизирует процесс
поиска сети.